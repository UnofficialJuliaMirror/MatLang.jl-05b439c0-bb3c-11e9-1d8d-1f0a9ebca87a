<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · MatLang</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="MatLang logo"/></a><h1>MatLang</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Functions</a><ul class="internal"><li><a class="toctext" href="#List-of-implemented-Functions-1">List of implemented Functions</a></li><li><a class="toctext" href="#Functions-Explanation-and-Examples-1">Functions Explanation and Examples</a></li></ul></li><li><a class="toctext" href="../development/">Development - Contribution</a></li><li><a class="toctext" href="../juliavsmatlab/">Native Julia noteworthy differences from MATLAB</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Functions</a></li></ul><a class="edit-page" href="https://github.com/juliamatlab/MatLang/blob/master/docs/src/functions.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h1><h2><a class="nav-anchor" id="List-of-implemented-Functions-1" href="#List-of-implemented-Functions-1">List of implemented Functions</a></h2><h4><a class="nav-anchor" id="Language_Fundamentals-:-1" href="#Language_Fundamentals-:-1">Language_Fundamentals :</a></h4><table>
    <tr>
        <td></td>
        <td>Sub Package</td>
        <td></td>
    </tr>
    <tr>
        <td>1</td>
        <td>Entering_Commands</td>
        <td>clcM</td>
    </tr>
    <tr>
        <td>2</td>
        <td>Matrices_and_Arrays</td>
        <td>zerosM, onesM, randM, eyeM, diagM, catM, horzcatM, vertcatM, squeezeM</td>
    </tr>
</table><ul><li><a href="#MatLang.blkdiagM-Tuple"><code>MatLang.blkdiagM</code></a></li><li><a href="#MatLang.catM-Tuple{Integer,Vararg{Any,N} where N}"><code>MatLang.catM</code></a></li><li><a href="#MatLang.clcM-Tuple{}"><code>MatLang.clcM</code></a></li><li><a href="#MatLang.eyeM-Tuple{Type,Integer,Integer}"><code>MatLang.eyeM</code></a></li><li><a href="#MatLang.horzcatM"><code>MatLang.horzcatM</code></a></li><li><a href="#MatLang.onesM-Tuple"><code>MatLang.onesM</code></a></li><li><a href="#MatLang.randM-Tuple"><code>MatLang.randM</code></a></li><li><a href="#MatLang.repelemM-Tuple{AbstractArray,Integer}"><code>MatLang.repelemM</code></a></li><li><a href="#MatLang.squeezeM-Tuple{AbstractArray}"><code>MatLang.squeezeM</code></a></li><li><a href="#MatLang.vertcatM"><code>MatLang.vertcatM</code></a></li><li><a href="#MatLang.zerosM-Tuple"><code>MatLang.zerosM</code></a></li></ul><p>To see the full progress see this link: https://github.com/juliamatlab/MatLang/projects</p><p>The full list of the functions that will be implemented in the future can be found <a href="https://www.mathworks.com/help/matlab/referencelist.html;jsessionid=e221a09e47ed26d2b333ea600f68?type=function">Here</a></p><h2><a class="nav-anchor" id="Functions-Explanation-and-Examples-1" href="#Functions-Explanation-and-Examples-1">Functions Explanation and Examples</a></h2><h3><a class="nav-anchor" id="Language-Fundamentals-1" href="#Language-Fundamentals-1">Language Fundamentals</a></h3><h4><a class="nav-anchor" id="Entering_Commands-1" href="#Entering_Commands-1">Entering_Commands</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatLang.clcM-Tuple{}" href="#MatLang.clcM-Tuple{}"><code>MatLang.clcM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">clcM()</code></pre><p>Clear Command Window for Juno or Atom IDE</p></div></div><a class="source-link" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/236834ff9b315fd8febbd2c365a43e0dc10c5967/src/Language_Fundamentals/Entering_Commands.jl#LL18-L22">source</a></section><h4><a class="nav-anchor" id="Matrices-and-Arrays-1" href="#Matrices-and-Arrays-1">Matrices and Arrays</a></h4><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatLang.blkdiagM-Tuple" href="#MatLang.blkdiagM-Tuple"><code>MatLang.blkdiagM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">blkdiagM(A1,A2,...)</code></pre><p>Creates a square matrix with A1,A2,... on the diagonal and the rest of the elements being 0. Works for both square and non-square matrices.</p><pre><code class="language-none">blkdiagM(A1,A2,..., :obj)</code></pre><p>Returns the object itself if you want to use BlockDiagonals methods. use collect(obj) to get the array.</p><p><strong>Examples</strong></p><pre><code class="language-julia">1 = 3 * ones(2, 2);
A2 = 4 * ones(2, 2);
A3 = rand(3, 3);
mBlkdiag1 = blkdiagM(A1, A2, A3)

mBlkdiag2 = blkdiagM(ones(2, 2), 2 * ones(2, 2)) # [ones(2, 2) zeros(2, 2); zeros(2, 2)  2 * ones(2, 2)]

A1 = ones(2, 4);
A2 = 2 * ones(3, 2);
mBlkdiag3 = blkdiagM(A1, A2) # [ones(2,4) zeros(2,2); zeros(3,4) 2*ones(3,2)]

mBlkdiag1obj = blkdiagM(:obj, A1, A2, A3)

mBlkdiag2obj = blkdiagM(:obj, ones(2, 2), 2 * ones(2, 2)) # Block Diagonal object for [ones(2, 2) zeros(2, 2); zeros(2, 2)  2 * ones(2, 2)]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/236834ff9b315fd8febbd2c365a43e0dc10c5967/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL215-L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatLang.catM-Tuple{Integer,Vararg{Any,N} where N}" href="#MatLang.catM-Tuple{Integer,Vararg{Any,N} where N}"><code>MatLang.catM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">catM(dim, A1, A2, ...)</code></pre><p>concatenates A1, A2, … , An along dimension dim.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mCat1 = catM(1, ones(3, 3), zeros(3, 3)) # [ones(3, 3); zeros(3, 3)]

mCat2 = catM(2, ones(3, 3), zeros(3, 3)) # [ones(3, 3) zeros(3, 3)]

mCat3 = catM(1, ones(3, 3), zeros(3, 3), 2 * ones(3, 3)) # [ones(3, 3); zeros(3, 3); 2 * ones(3, 3)]

mCat4 = catM(3, ones(2, 2, 2), zeros(2, 2, 2)) # [ones(2, 2, 2) zeros(2, 2, 2)]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/236834ff9b315fd8febbd2c365a43e0dc10c5967/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL275-L289">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatLang.eyeM-Tuple{Type,Integer,Integer}" href="#MatLang.eyeM-Tuple{Type,Integer,Integer}"><code>MatLang.eyeM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">eyeM(dim)         # square dim*dim matrix
eyeM(Type, dim)    # square dim*dim matrix
eyeM(dim, like = anArray) # to make an array with similar type of anArray
eyeM(dim1, dim2)   # giving size as a separate input numbers
eyeM(Type, dim1, dim2)   # giving size as a separate input numbers
eyeM(dim1, dim2, like = anArray) # to make an array with similar type of anArray
eyeM(sizeAsTuple) # giving size as a Tuple
eyeM(Type, sizeAsTuple) # giving size as a Tuple
eyeM(sizeAsTuple, like = anArray) # to make an array with similar type of anArray
eyeM(sizeAsArray) # non-efficient Matlab way
eyeM(Type, sizeAsArray) # non-efficient Matlab way
eyeM(sizeAsArray, like = anArray) # to make an array with similar type of anArray</code></pre><p>Creates 2D Identity matrix (can be non-square matrix).</p><p>Only 2 dimensions should be supplied othetwise you will receive an error.</p><p><strong>Examples</strong></p><pre><code class="language-julia">mEye0=eyeM(2); # [1 0 0; 0 1 0]

mEye1=eyeM(2,3); # [1 0 0; 0 1 0]

mEye2=eyeM(Int32,2,3); # [1 0 0; 0 1 0]

mEye3=eyeM(2,3, like = zerosM(Int8,2,2) )

mEye4=eyeM((2,2))  # giving size as a Tuple. In Julia we use (2,2) instead of giving it as [2,2]

mEye5=eyeM(Int32,(2,2))  # giving size as a Tuple. In Julia we use (2,2) instead of giving it as [2,2]

mEye6=eyeM([2,2]) # non-efficient Matlab way

mEye7=eyeM(Int32,[2,2]) # non-efficient Matlab way

s1=size(ones(2,3)) # getting size from another matrix or calculation
mEye8=eyeM(s1)  # giving size as a variable (Tuple).</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/236834ff9b315fd8febbd2c365a43e0dc10c5967/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL129-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatLang.horzcatM" href="#MatLang.horzcatM"><code>MatLang.horzcatM</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">horzcatM(A1, A2, …)</code></pre><p>Concatenate arrays horizontally</p><p><strong>Examples</strong></p><pre><code class="language-julia">mHCat1 = horzcatM(ones(3, 3), zeros(3, 3)) # [ones(3, 3) zeros(3, 3)]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/236834ff9b315fd8febbd2c365a43e0dc10c5967/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL292-L300">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatLang.onesM-Tuple" href="#MatLang.onesM-Tuple"><code>MatLang.onesM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">onesM(dim)         # square dim*dim matrix
onesM(Type, dim)    # square dim*dim matrix
onesM(dim, like = anArray) # to make an array with similar type of anArray
onesM(sizeAsArray) # non-efficient Matlab way
onesM(Type, sizeAsArray) # non-efficient Matlab way
onesM(sizeAsArray, like = anArray) # to make an array with similar type of anArray</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia">mOnes0=onesM(2) # same as ones(2,2)

mOnes1 = onesM(2, like = zerosM(Int32,2,2) )

mOnes2=onesM(2,2) # same as ones(2,2)

mOnes3=onesM(Int32,2,2) # same as ones(Int32,2,2)

mOnes4=onesM((2,2)) # giving size as Tuple

mOnes5=onesM(Int32,(2,2)) # giving size as Tuple and also the Int32 type

mOnes6=onesM([2,2]) # giving size as an Array, non-efficient Matlab way. Array should be Integer otherwise you will get errors.

mOnes7=onesM(Int32,[2,2]) # giving size as Array, non-efficient Matlab way</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/236834ff9b315fd8febbd2c365a43e0dc10c5967/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL53-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatLang.randM-Tuple" href="#MatLang.randM-Tuple"><code>MatLang.randM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">randM(dim)         # square dim*dim matrix
randM(Type, dim)    # square dim*dim matrix
randM(dim, like = anArray) # to make an array with similar type of anArray
randM(sizeAsArray) # non-efficient Matlab way
randM(Type, sizeAsArray) # non-efficient Matlab way
randM(sizeAsArray, like = anArray) # to make an array with similar type of anArray</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia">mRand0=randM(2) # same as rand(2,2)

mRand1 = randM(2, like = zerosM(Int32,2,2) )

mRand2=randM(2,2) # same as rand(2,2)

mRand3=randM(Int32,2,2) # same as rand(Int32,2,2)

mRand4=randM((2,2)) # giving size as Tuple

mRand5=randM(Int32,(2,2)) # giving size as Tuple and also the Int32 type

mRand6=randM([2,2]) # giving size as an Array, non-efficient Matlab way. Array should be Integer otherwise you will get errors.

mRand7=randM(Int32,[2,2]) # giving size as Array, non-efficient Matlab way</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/236834ff9b315fd8febbd2c365a43e0dc10c5967/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL91-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatLang.repelemM-Tuple{AbstractArray,Integer}" href="#MatLang.repelemM-Tuple{AbstractArray,Integer}"><code>MatLang.repelemM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">repelemM(V, count)</code></pre><p>Construct an array by repeating elements of array V by a given number of times specified by counts. if If count is a scalar, then each element of v is repeated &quot;count&quot; times</p><p><strong>Examples</strong></p><pre><code class="language-julia">V1 = [1 2 3 4];
mRepelem1 = repelemM(V1, 3) # [1 1 1 2 2 2 3 3 3 4 4 4]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/236834ff9b315fd8febbd2c365a43e0dc10c5967/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL314-L324">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatLang.squeezeM-Tuple{AbstractArray}" href="#MatLang.squeezeM-Tuple{AbstractArray}"><code>MatLang.squeezeM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">squeezeM(A)</code></pre><p>Drops all of the singleton dimensions of <code>A</code> (dimensions that are 1). If <code>A</code> contains only one element (i.e., all of its dimensions are singletons) then the output will be a zero-dimensional array.</p><p>If you know the dimension that you want to drop, use dropdims(A ; dims= dimensionsToRemove).</p><p>Only use this function if you don&#39;t know the dimensions that you want to remove, and you are sure that you are not removing important dimensions, and if you don&#39;t care about type stability.</p><p>Returns an array containing the same data as <code>A</code> but with no singleton dimensions; note that <code>arr</code> is NOT a copy of <code>A</code>, i.e., modifying the contents of <code>arr</code> will modify the contents of <code>A</code>. To get a copy use copy(arr).</p><p><strong>Examples</strong></p><pre><code class="language-julia">A1 = ones(2, 1, 2); # 3 dimensional
mSqueeze1 = squeezeM(A1) # [1 1; 1 1]

A2 = zeros(1, 4, 1);
A2[:, 1:4, ] = [5; 3; 6; 0]
mSqueeze2 = squeezeM(A2) # When it gets one dimensional, it is vertical.

mSqueeze2 == [5; 3; 6; 0] # true
mSqueeze2 == [5 3 6 0] # false</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/236834ff9b315fd8febbd2c365a43e0dc10c5967/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL335-L359">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatLang.vertcatM" href="#MatLang.vertcatM"><code>MatLang.vertcatM</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">vertcatM(A1, A2, …)</code></pre><p>Concatenate arrays vertically</p><p><strong>Examples</strong></p><pre><code class="language-julia">mVCat1 = vertcatM(ones(3, 3), zeros(3, 3)) # [ones(3, 3); zeros(3, 3)]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/236834ff9b315fd8febbd2c365a43e0dc10c5967/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL303-L311">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MatLang.zerosM-Tuple" href="#MatLang.zerosM-Tuple"><code>MatLang.zerosM</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">zerosM(dim)         # square dim*dim matrix
zerosM(Type,dim)    # square dim*dim matrix
zerosM(dim, like=anArray) # to make an array with similar type of anArray
zerosM(sizeAsArray) # non-efficient Matlab way
zerosM(Type, sizeAsArray) # non-efficient Matlab way
zerosM(sizeAsArray, like=anArray) # to make an array with similar type of anArray</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia">mZeros0=zerosM(2) # same as zeros(2,2)

mZeros1 = zerosM(2, like = zerosM(Int32,2,2) ) # like method

mZeros2=zerosM(2,2) # same as zeros(2,2)

mZeros3=zerosM(Int32,2,2) # same as zeros(Int32,2,2)

mZeros4=zerosM((2,2)) # giving size as Tuple

mZeros5=zerosM(Int32,(2,2)) # giving size as Tuple and also the Int32 type

mZeros6=zerosM([2,2]) # giving size as an Array, non-efficient Matlab way. Array should be Integer otherwise you will get errors.

mZeros7=zerosM(Int32,[2,2]) # giving size as Array, non-efficient Matlab way</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/juliamatlab/MatLang/blob/236834ff9b315fd8febbd2c365a43e0dc10c5967/src/Language_Fundamentals/Matrices_and_Arrays.jl#LL15-L41">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../development/"><span class="direction">Next</span><span class="title">Development - Contribution</span></a></footer></article></body></html>
